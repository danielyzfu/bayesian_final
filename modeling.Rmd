---
title: "Final Project - Bayesian Analysis"
output: pdf_document
---

```{r data_import}
#| message: false

library(readxl)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(lme4)
library(tidymodels)
library(purrr)
library(tidyr)
library(pROC)
library(groupdata2)
library(car)
library(brms)
library(tidybayes)
library(bayesplot)
library(posterior)
library(modelsummary)
```

```{r}
load("beatspy.RData")
m3_df = m3_df |>
  mutate(
    beat_spy = factor(
      beat_spy,
      levels = c(1, 0),      # 1 = event
      labels = c("yes", "no")
    ),
    gics_sector_name = factor(gics_sector_name),
    Ticker = factor(Ticker)
  )
m3_df$gics_sector_name = as.factor(m3_df$gics_sector_name)
m3_df$Ticker = as.factor(m3_df$Ticker)
set.seed(123)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Baseline Logistic
Fit a baseline logistic model to remove influential points before fitting (marginally) fancier frequentist + Bayesian models.

```{r}
baseline_logit = glm(
  beat_spy ~ log_pe + div_yield,
  data = m3_df,
  family = binomial(link = "logit")
)

cooks_d = cooks.distance(baseline_logit)
cooks_threshold = 4 / (nrow(m3_df) - length(coef(baseline_logit)))
plot(cooks_d,
     type = "h",
     main = "Diagnosing Influential Points",
     ylab = "Cook's Distance",
     xlab = "Observation")
abline(h = cooks_threshold, col = "red", lty = 2, lwd = 2)

influential = which(cooks_d > cooks_threshold)
#beatspy_clean = m3_df[-influential, ]
```

```{r}
baseline_logit |> summary()
```
```{r}
beatspy_clean = m3_df
```

# Frequentist

## Models

### Sector Models
Logistic regression models fitted within each sector

```{r}
sector_models = beatspy_clean |>
  group_split(gics_sector_name) |>
  setNames(unique(beatspy_clean$gics_sector_name)) |>
  map(~ glm(
    beat_spy ~ log_pe + div_yield,
    data = .x,
    family = binomial(link = "logit")
  ))

modelsummary(sector_models)
```

### Firm Mixed Effects
Random intercept + coefficient by firm
```{r}
#random intercept and random coefficient for firm
firm_re = glmer(
  beat_spy ~ log_pe + div_yield +
    (1 + log_pe + div_yield | Ticker),
  data = beatspy_clean,
  family = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa")
)

firm_re |> summary()
```

Random effect correlations are high, indicating multicollinearity. Model is likely too overparametrized.

### Sector Fixed Effects

```{r}
#pooled logistic model w sector fixed effects
sector_fe = glm(
  beat_spy ~ log_pe + div_yield + gics_sector_name,
  data = beatspy_clean,
  family = binomial(link = "logit")
)
summary(sector_fe)
```

### Sector RI
```{r}
sector_ri = glmer(
  beat_spy ~ log_pe + div_yield  + (1 | gics_sector_name),
  data = beatspy_clean,
  family = binomial(link = "logit")
)

summary(sector_ri)
```

### Nested
```{r}
nested = glmer(
  beat_spy ~ log_pe + div_yield + (1|gics_sector_name/Ticker),
  data = beatspy_clean,
  family = binomial(link = "logit")
)
nested |> summary()
```

### Sector RE
No coefficient for mean model, random intercept + coefficient for sector

```{r}
sector_re = glmer(
  beat_spy ~ log_pe + div_yield + (1 + log_pe + div_yield | gics_sector_name),
  data = beatspy_clean,
  family = binomial(link = "logit")
)

summary(sector_re)
```

## Model Comparison

### Information Criterion

```{r}
# manually back out AIC + BIC for sector models
# AIC = -2l + 2k
# BIC = -2l + log(n) * k 

sector_logLik = sum(sapply(sector_models, logLik))
sector_k = sum(sapply(sector_models, function(m) attr(logLik(m), "df")))

sector_AIC = -2 * as.numeric(sector_logLik) + 2 * sector_k
sector_BIC = -2 * as.numeric(sector_logLik) + 
              log(nrow(beatspy_clean)) * sector_k

# AIC
aic_comp = AIC(baseline_logit,
               firm_re,
               sector_fe,
               sector_re)
aic_comp = data.frame(
  Model = rownames(aic_comp),
  df = aic_comp$df,
  AIC = aic_comp$AIC,
  row.names = NULL
) |>
  rbind(data.frame(Model = "sector_models",
                   df = sector_k,
                   AIC = sector_AIC))

#BIC
bic_comp = BIC(baseline_logit,
               firm_re,
               nested,
               sector_fe,
               sector_ri,
               sector_re)
bic_comp = data.frame(
  Model = rownames(bic_comp),
  df = bic_comp$df,
  BIC = bic_comp$BIC,
  row.names = NULL
) |>
  rbind(data.frame(Model = "sector_models",
                   df = sector_k,
                   BIC = sector_BIC))
```

```{r}
aic_comp |> arrange(AIC)
bic_comp |> arrange(BIC)
```

### Predictive Performance

```{r}
#| warning: hide
#| message: hide
cv_df = beatspy_clean |>
  fold(k = 10, cat_col = "gics_sector_name")

folds = unique(cv_df$.folds)

cv_results = map_dfr(folds, function(f){
  
  train = filter(cv_df, .folds != f)
  test  = filter(cv_df, .folds == f)
  train <- droplevels(train)
  test  <- droplevels(test)
  
  # Mixed-effects logistic regression
  mixed_mod = glmer(
    beat_spy ~ log_pe + div_yield + (1 + log_pe + div_yield | Ticker),
    data = train,
    family = binomial,
    control = glmerControl(optimizer = "bobyqa")
  )
  pred_firm_re = predict(mixed_mod, newdata = test, type = "response", re.form = NA)
  
  # sector FE
  pooled_mod = glm(
    beat_spy ~ log_pe + div_yield + gics_sector_name,
    data = train,
    family = binomial
  )
  pred_sector_fe = predict(pooled_mod, newdata = test, type = "response")
  
  # Sector random effects
  pooled_int_mod = glmer(
    beat_spy ~ (log_pe + div_yield) | gics_sector_name,
    data = train,
    family = binomial
  )
  pooled_int_pred = predict(pooled_int_mod, newdata = test, type = "response")
  
  # Sector-by-sector
  sector_preds = test %>%
    group_by(gics_sector_name) %>%
    group_modify(~ {
      sect_train = filter(train, gics_sector_name == .y$gics_sector_name)
      mod = glm(beat_spy ~ log_pe + div_yield, data = sect_train, family = binomial)
      tibble(pred = predict(mod, newdata = .x, type = "response"))
    }) %>%
    pull(pred)
  
  tibble(
    Ticker = test$Ticker,
    true = test$beat_spy,
    mixed = pred_firm_re,
    pooled = pred_sector_fe,
    pooled_int = pooled_int_pred,
    sector = sector_preds
  )
})

cv_results = cv_results %>%
  mutate(
    true_bin = ifelse(true == "yes", 1, 0)
  )
```

```{r}
auc_table <- tibble(
  model = c("Firm Random Effects", "Sector Fixed Effect", "Sector Random Intercept", "Sector Models"),
  auc = c(
    auc(cv_results$true, cv_results$mixed),
    auc(cv_results$true, cv_results$pooled),
    auc(cv_results$true, cv_results$pooled_int),
    auc(cv_results$true, cv_results$sector)
  )
)

auc_table |> arrange(desc(auc))
```

## Model Diagnostics

### Multicollinearity

```{r}
vif(sector_fe)
```

### Influence/Outliers

```{r}
plot(cooks.distance(sector_fe), type = "h", ylab = "Cook's Distance")
abline(h = 4/length(fitted(sector_fe)), col = "red")
```

### Leverage

```{r}
plot(hatvalues(sector_fe), type = "h")
abline(h = 3*(length(coef(sector_fe))+1)/length(fitted(sector_fe)), col = "red")
```

### Residuals

```{r}
plot(residuals(sector_fe, type = "deviance"),
     col = rgb(0, 0, 0, 0.25))
```

```{r}
ggplot(
  data.frame(
    fitted = fitted(sector_fe),
    resid = residuals(sector_fe, type = "deviance")
  ),
  aes(x = fitted, y = resid)
) +
  geom_point(alpha = 0.2) +
  geom_smooth(se = FALSE, color = "blue") +
  geom_hline(yintercept = 0, color = "red") +
  theme_minimal()
```

```{r}
crPlots(sector_fe)
```

# Bayesian

## Models

### Simple Logistic

\begin{align*}
Y_{i,t} \sim Bernoulli(p_{i,t})\\
logit(p_{i,t}) = \beta_0 + \beta_1 + log(PE_{i,t}) + \beta_2 DivYield_{i,t}
\end{align*}

```{r}
#| results: hide
bayes_baseline = brm(
  beat_spy ~ log_pe + div_yield,
  data = beatspy_clean,
  family = bernoulli(link = "logit"),
  seed = 123
)
```

```{r}
summary(bayes_baseline)$fixed
```

Rhats are \~1 and effective sample sizes \>\> 100

```{r}
draws_bayes_baseline = bayes_baseline |>
  as_draws_array()

mcmc_trace(draws_bayes_baseline,
           pars = c("b_log_pe", "b_div_yield", "b_Intercept"))
```

No discernable pattern from trace plots

```{r}
mcmc_acf_bar(
  draws_bayes_baseline,
  pars = c("b_log_pe", "b_div_yield", "b_Intercept")
)
```

acfs fall off quickly

### Model 2 (Nested random intercepts)

\begin{align*}
logit(p_{i,t}) = \beta_0 + \beta_1 log(PE_{i,t}) + \beta_2 DivYield_{i,t} + u_{j} + v_i
\end{align*}

```{r}
#| results: hide
bayes_model2 = brm(
  beat_spy ~ log_pe + div_yield + (1 | gics_sector_name/Ticker),
  data = m3_df,
  family = bernoulli(link = "logit"),
  seed = 123
)
```

```{r}
summary(bayes_model2)
```

Rhats are all \~1, effective sample sizes \>\> 100

```{r}
draws_model2 = bayes_model2 |>
  as_draws_array()

mcmc_trace(
  draws_model2,
  pars = c("b_log_pe",
           "b_div_yield",
           "b_Intercept",
           "sd_gics_sector_name__Intercept",
           "sd_gics_sector_name:Ticker__Intercept")
)
```

```{r}
mcmc_acf_bar(
  draws_model2,
  pars = c("b_log_pe", "b_div_yield", "b_Intercept", "sd_gics_sector_name__Intercept", "sd_gics_sector_name:Ticker__Intercept")
)
```

acfs fall off quickly

### Model 3 (Mixed Effects + firm-level random slopes/intercepts)

$$logit(p_{i,t}) = \beta_0 + \beta_1 log(PE_{i,t}) + \beta_2 DivYield_{i,t} + b_{0,i} + b_{1,i}log(PE_{i,t}) + b_{2,i} DivYield_{i,t}$$

Covariates are centered

```{r}
#| results: hide
bayes_model3 = brm(
  beat_spy ~ log_pe + div_yield + (1 + log_pe + div_yield | Ticker),
  data = m3_df |> mutate(log_pe = scale(log_pe),
                         div_yield = scale(div_yield)),
  family = bernoulli(link = "logit"),
  seed = 123
)
```

```{r}
summary(bayes_model3)
```

Rhats are \~1 and effective sample sizes \>\> 100

```{r}
draws_bayes_mixed = bayes_model3 |>
  as_draws_array()

mcmc_trace(draws_bayes_mixed,
           pars = c("b_log_pe", "b_div_yield", "b_Intercept","sd_Ticker__Intercept", "sd_Ticker__log_pe", "sd_Ticker__div_yield"))
```

No discernable pattern from trace plots

```{r}
mcmc_acf_bar(
  draws_bayes_mixed,
  pars = c("b_log_pe", "b_div_yield", "b_Intercept","sd_Ticker__Intercept", "sd_Ticker__log_pe", "sd_Ticker__div_yield"))
```

### Model 4 (Pooled + sector FE)

$$logit(p_{i,t}) = \beta_0 + \beta_1 log(PE_{i,t}) + \beta_2 DivYield_{i,t} + \sum^{J-1} \gamma_j \mathbb{1}(Sector_i=j)$$

```{r}
#| results: hide
bayes_fe = brm(
  beat_spy ~ log_pe + div_yield + factor(gics_sector_name),
  data = m3_df,
  family = bernoulli(link = "logit"),
  seed = 123
)
```

```{r}
summary(bayes_fe)
```

Rhats are \~1 and effective sample sizes \>\> 100

```{r}
draws_bayes_fe = bayes_fe |>
  as_draws_array()

mcmc_trace(draws_bayes_fe,
           pars = c("b_log_pe", "b_div_yield", "b_Intercept","b_factorgics_sector_nameInformationTechnology"))
```

No discernable pattern from trace plots

```{r}
mcmc_acf_bar(
  draws_bayes_fe,
  pars = c("b_log_pe", "b_div_yield", "b_Intercept","b_factorgics_sector_nameInformationTechnology")
)
```

# 

## Model Comparison

```{r}
loo_compare(loo(bayes_model1),
            loo(bayes_model2),
            loo(bayes_model3),
            loo(bayes_fe))
```

LOOCV favors the `pooled model with sector fixed effects` and the `model with nested random intercepts` over the `baseline pooled model` and `mixed effects model w/ firm-level random intercepts and slopes`.

The sector FE and nested random intercepts models are generally comparable (firm-level variation may be small)

## Model Checking

```{r}
pp_check(bayes_fe, ndraws=100)
```
